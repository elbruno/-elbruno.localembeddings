# Plan — Improvement Scenarios 1 & 2

**Created:** 2026-02-14 11:33  
**Scope:** Implement Scenario 1 (**Built-in InMemoryVectorStore for VectorData Package**) and Scenario 2 (**FindClosest Convenience API**) with incremental, test-first changes.

## Goals

- Deliver a built-in, dependency-light in-memory vector store experience in `ElBruno.LocalEmbeddings.VectorData`.
- Deliver ergonomic `FindClosest` APIs in `ElBruno.LocalEmbeddings` to remove repetitive semantic-search boilerplate.
- Keep APIs intuitive for samples while preserving backward compatibility.
- Add targeted tests and documentation updates for both scenarios.

## Out of Scope (for this plan)

- Distributed or persistent vector store connectors.
- Approximate nearest neighbor (ANN) indexing (HNSW/IVF/etc.).
- Major API redesigns in existing public types.

## Delivery Order

1. **Scenario 2 first (quick win, low risk)**
2. **Scenario 1 second (larger but high-impact foundation)**

This order provides immediate developer-experience value while reducing pressure on larger VectorData changes.

---

## Scenario 2 — FindClosest Convenience API

### Proposed API Surface

- Add a result record in core package:
  - `SemanticSearchResult(string Text, int Index, float Score)`
- Add extension methods (or instance methods if preferred by existing style):
  1. `FindClosestAsync(this LocalEmbeddingGenerator generator, string query, IReadOnlyList<string> corpus, IReadOnlyList<Embedding<float>>? corpusEmbeddings = null, int topK = 3, float? minScore = null, CancellationToken cancellationToken = default)`
  2. Optional typed overload:
     - `FindClosestAsync<T>(..., IReadOnlyList<T> corpus, Func<T, string> textSelector, ... )`
  3. Optional precomputed helper:
     - `FindClosest(this Embedding<float> queryEmbedding, IReadOnlyList<Embedding<float>> corpusEmbeddings, int topK = 3, float? minScore = null)` returning index/score pairs (or full result for text overload only).

### Behavioral Rules

- Validate `query`, `corpus`, `topK`, and alignment between `corpus` and `corpusEmbeddings`.
- If `corpusEmbeddings` is null, generate embeddings in batch via `GenerateAsync`.
- Score with cosine similarity and sort descending by score.
- Apply `minScore` filter when provided.
- Return at most `topK` results.
- Preserve deterministic ordering for equal scores (tie-break by index).

### Implementation Tasks

- [ ] Add `SemanticSearchResult` type in core project.
- [ ] Implement FindClosest extensions with nullable-safe argument checks.
- [ ] Add XML docs with usage examples and complexity note (linear scan $O(n)$).
- [ ] Add cancellation propagation in async overloads.

### Tests (xUnit, table-driven where applicable)

- [ ] Returns expected top-K ordering for deterministic sample vectors.
- [ ] Generates corpus embeddings when `corpusEmbeddings` is null.
- [ ] Throws when corpus and embedding counts differ.
- [ ] Honors `minScore` filter.
- [ ] Handles `topK` boundaries (`1`, `==count`, `>count`, invalid values).
- [ ] Typed overload maps text correctly.

### Docs/Samples Updates

- [ ] Update `README.md` semantic-search snippet to one-line `FindClosestAsync` usage.
- [ ] Update `docs/getting-started.md` and `docs/api-reference.md` with new API examples.
- [ ] Optionally simplify one sample (`samples/ConsoleApp` or `samples/RagChat`) to showcase the API.

---

## Scenario 1 — Built-in InMemoryVectorStore for VectorData Package

### Packaging Decision

- **Default plan:** implement directly in existing `ElBruno.LocalEmbeddings.VectorData` package.
- Re-evaluate separate `...VectorData.InMemory` package only if dependency graph or package size becomes problematic.

### Proposed Components

- `InMemoryVectorStore : VectorStore`
- `InMemoryVectorStoreCollection<TKey, TRecord> : VectorStoreCollection<TKey, TRecord>`
- Internal reflection metadata helper(s) for:
  - `[VectorStoreKey]`
  - `[VectorStoreData]`
  - `[VectorStoreVector]`
- Thread-safe storage using `ConcurrentDictionary<string, object>` (collections) and `ConcurrentDictionary<TKey, TRecord>` (records).

### DI Extensions

- Add convenience registration in `ElBruno.LocalEmbeddings.VectorData.Extensions`:
  - `AddLocalEmbeddingsWithInMemoryVectorStore(...)`
  - `AddVectorStoreCollection<TKey, TRecord>(string collectionName)`
- Ensure coexistence with existing vector store registration patterns.

### Search Behavior

- Implement cosine similarity search in `SearchAsync<TInput>`.
- Support at minimum embedding-vector input for semantic similarity.
- Return top-K ordered matches by score.
- Keep implementation simple and predictable; no ANN index in first version.

### Implementation Tasks

- [ ] Add in-memory store and collection classes.
- [ ] Implement reflection-based key/data/vector discovery with cached metadata.
- [ ] Implement upsert/get/delete/list primitives expected by abstractions.
- [ ] Implement `SearchAsync<TInput>` with cosine similarity and ranking.
- [ ] Add DI extension methods and argument validation.
- [ ] Ensure nullable annotations and XML docs for public APIs.

### Tests (xUnit)

- [ ] Can create and resolve named collection via DI.
- [ ] Upsert + retrieve record lifecycle works.
- [ ] Search returns expected nearest records (deterministic vectors).
- [ ] Concurrent upsert/search does not throw and remains consistent.
- [ ] Missing required vector/key annotations yields clear exceptions.
- [ ] Search with empty collection returns empty set.

### Docs/Samples Updates

- [ ] Update `docs/vector-data-integration.md` (or equivalent) with in-memory quick start.
- [ ] Update `README.md` vector store snippet to avoid Semantic Kernel requirement.
- [ ] Update/add sample demonstrating end-to-end local embeddings + in-memory vector store.

---

## Cross-Cutting Validation

- [ ] `dotnet build` from repo root.
- [ ] `dotnet test` from repo root.
- [ ] Ensure no warnings (warnings-as-errors enabled).
- [ ] Verify API docs compile and examples are accurate.

## Risks and Mitigations

- **Reflection overhead in VectorData path**  
  Mitigation: cache metadata per `TRecord` and avoid repeated reflection in hot paths.

- **Behavior mismatches with `Microsoft.Extensions.VectorData` expectations**  
  Mitigation: align method semantics with abstractions and add focused unit tests for contract behavior.

- **Public API expansion risk**  
  Mitigation: keep APIs minimal and additive; avoid breaking existing signatures.

## Definition of Done

- Scenario 2 APIs are implemented, documented, and tested.
- Scenario 1 in-memory store is implemented, DI-integrated, documented, and tested.
- Build and tests pass from repository root.
- Docs/samples show the new “minimal boilerplate” happy path.
